<!doctype html>
<script src=/boot.js></script>
<style>
    html {
      --radius: 3em;
      --diameter: calc(var(--radius) * 2);
      --outset: 10px;
      --tron: fuchsia;
    }

    .core {
        width: var(--diameter);
        height: var(--diameter);
        border-radius: var(--radius);
        line-height: var(--diameter);
        text-align: center; 
        background: var(--silver-dark);
        color: var(--midnight-darkest);
        font-variant: small-caps;
        font-weight: bold;
        font-size: 16pt;
        position: relative;
        transition: background 0.3s;
    }

    .core::after {
        --neg-outset: calc(0px - var(--outset));
        --outer-radius: calc(var(--radius) + var(--outset));

        position: absolute;
        top: var(--neg-outset);
        left: var(--neg-outset);
        bottom: var(--neg-outset);
        right: var(--neg-outset);
        border: 2px solid var(--grey-base);
        content: '';
        border-radius: var(--outer-radius);
        z-index: -100;
        background: var(--midnight-darkest);
    }

    .processor {
      --size: 7em;
      width: calc(var(--size) - 0.5em);
      height: var(--size);
      line-height: var(--size);
      position: relative;
      z-index: 100;
      color: var(--tron);
      margin-left: 2em;
      margin-right: 1em;
      font-variant: small-caps;
    }

    .bg {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      z-index: -100;
    }

    .processor .bg {
      left: -0.5em;
    }

    .bg polygon,rect,line {
      stroke: var(--tron);
      stroke-width: 1px;
      fill: transparent;
      transition: stroke 1s;
    }

    .data-core {
      width: calc(2 * var(--diameter));
      height: calc(2 * var(--diameter));
      display: flex;
      flex-flow: column;
      padding: 0;
      position: relative;
      align-items: center;
      justify-content: space-evenly;
      background: transparent;
      color: fuchsia;
      font-variant: small-caps;
      --tron: fuchsia;
    }
    
    .data-core > .core::after {
      border-color: var(--tron);      
    }

    .data-core:hover > a[href].core {
      background: var(--midnight-darker);
      color: var(--grey-base);
    }

    .data-core > a[href].core {
      background: fuchsia;
      color: var(--midnight-darker);
    }

    a[href].core:hover {
      text-decoration: none;
    }

    .data-core > label {
      color: var(--tron);
      position: absolute;
      bottom: -0.2em;
      padding: 4px;
      border: thin solid var(--tron);
      background: var(--midnight-darkest);      
    }
    
    a[href].core {
      color: var(--midnight-darkest);
    }

    .flow-lr {
      display: flex;
      flex-flow: row;
      align-items: center;
      justify-content: center;
    }


    .corebox {
      transition: transform 0.5s;
      transform: rotate(45deg);
    }

    .data-core:hover {
      --tron: var(--grey-lighter);
    }

    .data-core:hover .corebox {
      transform: none;
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
</style>

<div id=view>
<main markdown>
<header>
  <h1>introducing core schemas</h1>
</header>

Let's nail down some concepts and nomenclature.

## Core Schemas

<div class=flow-lr>
  <a href=using/pre-0 class=core>
    core schema
  </a>
</div>

A [core schema](using/pre-0) is a GraphQL schema which follows the [core specification](using/pre-0). It is a schema designed to function as a single document which configures a *data core*.

Primarily, this means that it uses the `@core` directive to reference versioned specifications for the directives it contains:

```graphql
#::[Small core schema example]
schema
  @core(using: "https://lib.apollo.dev/core/v1.0")
  @core(using: "https://specs.example.com/myDirective/v0.9")
{
    query: Query
}

type SomeType {
  # The behavior of this directive is specified by
  # https://specs.example.com/myDirective/v0.9
  someField: Int @myDirective
}

# Directive signatures are never implicit, and must always
# be defined by the document:
directive @myDirective on FIELD_DEFINITION
directive @core(spec: String) repeatable on SCHEMA_DEFINITION
```

It may seem that core schemas don't do much on their own, and that's because don't! The core specification simply provides a way to clearly identify what a document *means* by a directive of a particular name. The `core` spec also provides clear rules for namespace resolution, and the `as` mechanism to change the name of a directive:

```graphql
schema
  @core(using: "https://lib.apollo.dev/core/v1.0")
  @core(using: "https://specs.example.com/myDirective/v0.9", as: "dir")
{
    query: Query
}

type SomeType {  
  someField: Int @dir
}

# The directive signature changes too:
directive @dir on FIELD_DEFINITION
directive @core(spec: String) repeatable on SCHEMA_DEFINITION
```

The URLs we point to with `@core(using:)` are not currently machine readable. They are, however, *semantically versioned*. This lets us detect breaking changes and make simplifying assumptions about the behavior of directives during processing. For example, composers can coalesce the references for compatible versions of specs into one without knowing the details of the specs in question.

### Previous names

- the `@core` directive was previously named the `@using` directive
- "core schemas" have been known variously as "machine schemas", "using schemas", and "csdl".

### Export schema &amp; machinery

When talking about a core schema, we can broadly break it into two pieces:
- an *export schema*, which contains all the elements (objects, interfaces, enums, directives, etc.) which **will** be visible to clients
- *machinery*, typically consisting of directives and things that can be arguments to directives (like enums and input objects), which **will not** be visible to clients

*Machinery* will generally be either directives which are referenced using the `@core` directive, or associated types which are prefixed with the name of their spec:

```graphql
#::[The join__Graphs enum is machinery and will not be visible to clients]
schema
  @core(spec: "https://lib.apollo.dev/core/v0.1")
  @core(spec: "https://lib.apollo.dev/join/v0.4")
{
  query: Query
}

# The join__Graphs enum is machinery belonging to the join spec
# referenced above. It will not be exported to clients.
enum join__Graphs {
  # ...
}
```

Note that "should not be visible to clients" does not mean "will never be visible to any external system". We may want to provide an endpoint to inspect the core schema of a running serviceâ€”for example, federated services might wish to make their core schemas available to the composer.

## Processors

<div class=flow-lr>
  <a href=using/pre-0 class='core'>
    input
  </a>
  <div class=processor>
    <svg class=bg viewBox='0 0 100 100' height='100' width='100'><polygon points='1,0 100,50 1,100'/></svg>
    processor
  </div>
  <a href=using/pre-0 class='core'>
    intermediate 1
  </a>
  <div class=processor>
    <svg class=bg viewBox='0 0 100 100' height='100' width='100'><polygon points='1,0 100,50 1,100'/></svg>
    processor
  </div>
  <a href=using/pre-0 class='core'>
    output
  </a>
</div>

**Processors** read a core schema as input and produce a core schema as output. A processor may rename types and fields, perform validations, and so on.

## Data core

<figure>
  <div class=flow-lr>
    <div class=data-core>
      <svg class='bg corebox' viewBox='0 0 100 100' height='100' width='100'>
        <rect x=0 y=0 width=100 height=100 />
        <line x1=0 y1=0 x2=100 y2=100 />
        <line x1=100 y1=0 x2=0 y2=100 />
        <line x1=0 y1=50 x2=100 y2=50 />
        <line x1=50 y1=0 x2=50 y2=100 />
      </svg>    
      <a href=using/pre-0 class=core>
        core schema
      </a>
      <label>data core</label>
    </div>
  </div>
</figure>
<br>

A "data core" is some piece of software that picks up a core schema and uses it to provide some piece of the data layer. A graph router (or "gateway") is a data core; so is a server which understands core schemas. We can imagine other, future data cores: a batch processor, for example, might perform background processing tasks based on events and data in the schema, as defined by (some as yet undefined) directives. We might have caching data cores ("cache cores"), which only know how to securely serve previously cached results (taking the load off gateways or other backend services).

Its our goal and intention that eventually data cores will get all their configuration information from the core schema they're loaded with. This is, however, not a firm requirement. In particular, the first products we release as data cores will almost continue to support various out-of-schema configuration methods.

